---
title: "Week 0 : About DP and better options"
date: 2025-04-20
categories: [Weekly Report]
tags: [BOJ, Python, DFS/BFS, DP, Number Theory]
---

# ENGLISH
---
## About DP (Dynamic Programing)

Dynamic Programming (DP) is a method for solving problems by breaking them down into  
smaller overlapping subproblems, solving each subproblem only once,  
and reusing the result.  

This approach is surprisingly effective.  
It is significantly more efficient in terms of memory usage and execution time compared to BFS, DFS, or brute-force search.   

The following code examples show problems I initially tried to solve using BFS or DFS but failed,  
and later succeeded by switching to a dynamic programming approach.
<br>

---
## Problem: [BOJ 1463](https://www.acmicpc.net/problem/1463) make 1
<details>
<summary style="font-size: 20px;">Problem Description</summary>
You are given an integer X, and you can perform the following three operations:  
If X is divisible by 3, divide it by 3.  
If X is divisible by 2, divide it by 2.  
Else, subtract 1 from X.  

Given an integer N, determine the minimum number of operations required to reduce it to 1 using the operations above.
</details>

## BFS approach

```python
from collections import deque
n = int(input())
visited = set([x for x in range(2,n+1)]) # check whether visted that number
new = deque([(1,0)]) # BFS usually use que
while n in visited :
    index, num = new.popleft()
    next_number = index + 1
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number,num+1))
    next_number = index * 2
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number, num+1))
    next_number = index * 3
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number, num+1))
print(num+1 if n != 1 else 0)
```

## DP approach

```python
n = int(input())
turns = [float("inf")] * (n+1)
turns[1] = 0
for i in range(2,n+1) :
    minimum = []
    if i%3 == 0 :
        minimum.append(turns[i//3])
    if i%2 == 0 :
        minimum.append(turns[i//2])
    minimum.append(turns[i-1])
    turns[i] = min(minimum) + 1
print(turns[n])
```
**Rather than exploring every case with BFS, you can just add +1 to the minimum steps of previous numbers, since each value builds on the last.**
<br>
<br>

---
## Problem: [BOJ 2579](https://www.acmicpc.net/problem/2579) go up the stairs
<details>
<summary style="font-size: 20px;">Problem Description</summary>

There are n stairs, each with a random score value.  
You can climb either one or two stairs at a time.  
You cannot step on three consecutive stairs. (Note: the starting point is not considered a stair.)  
You must step on the last stair to complete the climb.

</details>

## DFS approach

```python
from collections import deque
n = int(input())
stairs = [0]
for _ in range(n) :
    stairs.append(int(input()))
que = deque([(0,0,0)])
total = set()
while que :
    score, succession, row = que.pop() # pop -> DFS, leftpop -> BFS?
    if row > n :
        continue
    if row == n :
        total.add(score)
        continue
    if row == n-1 :
        if succession < 2:
            row += 1
            que.append((score+stairs[row], succession+1,row))
            continue
        else :
            continue
    if succession < 2 :
        row += 1
        que.append((score+stairs[row], succession+1,row))
        row += 1
        que.append((score+stairs[row], 1,row))
    else :
        row += 2
        que.append((score+stairs[row], 1,row))

print(max(total))
```

## DP approach

```python
n = int(input())
stairs = [0]
for _ in range(n) :
    stairs.append(int(input()))
stair_max_score = [0] * (n+1)
try :
    stair_max_score[1] = stairs[1]
    stair_max_score[2] = stairs[2] + stairs[1]
    stair_max_score[3] = max(stairs[3] + stairs[1], stairs[3] + stairs[2])
    for i in range (4,n+1):
        stair_max_score[i] = max(stairs[i-1] + stair_max_score[i-3], stair_max_score[i-2]) + stairs[i]
except IndexError :
    pass
print(stair_max_score[n])
```

**Instead of searching all possible cases with DFS, you can observe that each stair has a maximum achievable score.**  
**The maximum score for the last stair is calculated by taking the greater of the following two options:**
**1. the maximum score at `last stair - 2`**  
**2. the maximum score at `last stair - 3` plus the score of last stair - 1**  
**then adding the score of the last stair itself.**

<br>
<br>
<br>

---

# But DP is not allways the fastest way

## Problem: [BOJ 17626](https://www.acmicpc.net/problem/17626) Four Squares
<details>
<summary style="font-size: 20px;">Problem Description</summary>

According to Lagrange's Four Square Theorem,
every natural number can be expressed as the sum of four or fewer perfect squares.  
For example: 15663 = 1252Â² + 62Â² + 12Â² + 12Â²  

Given an integer N, determine the minimum number of perfect squares needed to represent N.
</details>

<br>

Using `DP`, you can first find all perfect squares less than N.  
Then, for each of those squares, subtract it from N and calculate how many perfect squares are needed to represent the remainder.   
example : `1566 - 1252Â² = 4,132 = 62Â² + 12Â² + 12Â² -> 3 perfect squares needed`  

This approach is valid, but there exists a **faster and more intuitive method** â€” using Math (Number Theory).


## Mathematical approach

```python
def how_many_primes(n):
    primes = [x*x for x in range(1,int(n**0.5)+1)]
    if n in primes:
        return 1
    for i in primes:
        if n - i in primes:
            return 2
    while n%4 == 0:
        n //= 4
    if n%8 == 7:
        return 4
    else :
        return 3

n = int(input())
print(how_many_primes(n))

```

#### 1. Create a list of all perfect squares less than or equal to N  
â†’ If N is included in the list, the answer would be `1`  
  
#### 2. Subtract each perfect square in the list from N  
â†’ If the remainders is included the list (is a perfect square), the answer would be `2`  

#### 3. Check n, k âˆˆ â„¤âº âˆª {0}, N = 4â¿(8k + 7)  
â†’ According to Lagrange's Four Square Theorem, if N satisfies that condition, the answer would be `4`

#### 4. If none of the above conditions are met  
â†’ The answer would be `3`
<br>

### However, the approach above is difficult to apply without knowledge of number theory  
If you're not familiar with number theory, DP can still solve the problem.  
But through this, I realized that having mathematical knowledge and thinking skills is also important to become a better coder.

---
## ğŸ—“ï¸ Plan for This Week
- ğŸ“š Complete all problems in Baekjoon Class 3
- ğŸ§  Fully understand all Class-level concepts
- ğŸ“ Study graph theory in Discrete Mathematics, including DAGs and SCC compression
- ğŸ Review Python basic syntax



<br>
<br>
<br>
<br>
<br>

# í•œêµ­ì–´
---
## DP (ë™ì  ê³„íšë²•)

ë™ì  ê³„íšë²•ì€ ë¬¸ì œë¥¼ í•´ê²°í•  ë•Œ, í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ ì„œ í‘¸ëŠ” ë°©ì‹ì´ë‹¤.  
ì‘ì€ ë¬¸ì œë“¤ì´ ë°˜ë³µë  ë•Œ, í•œë²ˆ í‘¼ ì‘ì€ ë¬¸ì œì˜ ê²°ê³¼ë¥¼ ê¸°ì–µí•´ì„œ ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•Šë„ë¡ í•˜ëŠ” ë°©ë²•ì´ë‹¤.  

ì´ ë°©ë²•ì€ ìƒê°ë³´ë‹¤ ë§ì´ ìœ ìš©í•˜ë‹¤. BFS/DFS í˜¹ì€ ì™„ì „íƒìƒ‰ì„ í•  ë•Œì— ë¹„í•´  
ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ë‚˜ ì‹œê°„ì´ ì†Œìš”ëŸ‰ ë©´ì—ì„œ ì••ë„ì ìœ¼ë¡œ ìœ ë¦¬í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

ì•„ë˜ì˜ ì½”ë“œëŠ” BFS/DFSë¡œ ë„ì „í–ˆë‹¤ê°€ ì‹¤íŒ¨í•œ í›„, DPë¡œ ë¡œì§ì„ ë°”ê¿” í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•œ ì˜ˆì‹œë“¤ì´ë‹¤.
<br>

---
## ë¬¸ì œ: [ë°±ì¤€ 1463](https://www.acmicpc.net/problem/1463) 1ë¡œ ë§Œë“¤ê¸°
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>
ì •ìˆ˜ Xì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì—°ì‚°ì€ ë‹¤ìŒê³¼ ê°™ì´ ì„¸ ê°€ì§€ ì´ë‹¤.  
Xê°€ 3ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ë©´, 3ìœ¼ë¡œ ë‚˜ëˆˆë‹¤.  
Xê°€ 2ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ë©´, 2ë¡œ ë‚˜ëˆˆë‹¤.  
1ì„ ëº€ë‹¤.  

ì •ìˆ˜ Nì´ ì£¼ì–´ì¡Œì„ ë•Œ, ìœ„ì™€ ê°™ì€ ì—°ì‚° ì„¸ ê°œë¥¼ ì ì ˆíˆ ì‚¬ìš©í•´ì„œ 1ì„ ë§Œë“¤ë ¤ê³  í•œë‹¤.   
ì—°ì‚°ì„ ì‚¬ìš©í•˜ëŠ” íšŸìˆ˜ì˜ ìµœì†Ÿê°’ì„ ì¶œë ¥í•˜ì‹œì˜¤.
</details>

## BFSë¡œ êµ¬í˜„

```python
from collections import deque
n = int(input())
visited = set([x for x in range(2,n+1)]) # ê·¸ ìˆ«ìë¡œ ê°”ëŠ”ì§€ í™•ì¸
new = deque([(1,0)]) # BFSëŠ” íë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì •ì„
while n in visited :
    index, num = new.popleft()
    next_number = index + 1
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number,num+1))
    next_number = index * 2
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number, num+1))
    next_number = index * 3
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number, num+1))
print(num+1 if n != 1 else 0)
```

## DPë¡œ êµ¬í˜„

```python
n = int(input())
turns = [float("inf")] * (n+1)
turns[1] = 0
for i in range(2,n+1) :
    minimum = []
    if i%3 == 0 :
        minimum.append(turns[i//3])
    if i%2 == 0 :
        minimum.append(turns[i//2])
    minimum.append(turns[i-1])
    turns[i] = min(minimum) + 1
print(turns[n])
```

**BFSë¡œ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ì°¾ê¸°ë³´ë‹¤ëŠ”, ì–´ë–¤ ìˆ«ìë“  ë„ë‹¬í•˜ëŠ” ë° í•„ìš”í•œ ìµœì†Œ íšŸìˆ˜ê°€ ì¡´ì¬í•˜ë¯€ë¡œ,**  
**ê²°êµ­ ì›í•˜ëŠ” ìˆ«ìë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ” ìˆ«ìë“¤ ì¤‘ ê°€ì¥ ì‘ì€ ìµœì†Œ íšŸìˆ˜ì— +1ì„ ë”í•œ ê°’ì´ ì •ë‹µì´ ëœë‹¤.**
<br>
<br>

---
## ë¬¸ì œ: [ë°±ì¤€ 2579](https://www.acmicpc.net/problem/2579) ê³„ë‹¨ ì˜¤ë¥´ê¸°
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>

ê³„ë‹¨ nê°œëŠ” ê°ê° ëœë¤í•œ ê°’ì„ ê°€ì§„ë‹¤  
ê³„ë‹¨ì€ í•œë²ˆì— í•œ ê³„ë‹¨ í˜¹ì€ ë‘ ê³„ë‹¨ì”© ì˜¤ë¥¼ ìˆ˜ ìˆë‹¤  
ì—°ì†ëœ 3ê°œì˜ ê³„ë‹¨ì„ ë°Ÿì„ ìˆ˜ëŠ” ì—†ë‹¤ (ì‹œì‘ì§€ì ì€ ê³„ë‹¨ì´ ì•„ë‹˜)  
ë§ˆì§€ë§‰ ê³„ë‹¨ì€ ë°˜ë“œì‹œ ë°Ÿì•„ì•¼í•œë‹¤

</details>

## DFSë¡œ êµ¬í˜„

```python
from collections import deque
n = int(input())
stairs = [0]
for _ in range(n) :
    stairs.append(int(input()))
que = deque([(0,0,0)])
total = set()
while que :
    score, succession, row = que.pop() # pop -> DFS, leftpop -> BFS?
    if row > n :
        continue
    if row == n :
        total.add(score)
        continue
    if row == n-1 :
        if succession < 2:
            row += 1
            que.append((score+stairs[row], succession+1,row))
            continue
        else :
            continue
    if succession < 2 :
        row += 1
        que.append((score+stairs[row], succession+1,row))
        row += 1
        que.append((score+stairs[row], 1,row))
    else :
        row += 2
        que.append((score+stairs[row], 1,row))

print(max(total))
```

## DPë¡œ êµ¬í˜„

```python
n = int(input())
stairs = [0]
for _ in range(n) :
    stairs.append(int(input()))
stair_max_score = [0] * (n+1)
try :
    stair_max_score[1] = stairs[1]
    stair_max_score[2] = stairs[2] + stairs[1]
    stair_max_score[3] = max(stairs[3] + stairs[1], stairs[3] + stairs[2])
    for i in range (4,n+1):
        stair_max_score[i] = max(stairs[i-1] + stair_max_score[i-3], stair_max_score[i-2]) + stairs[i]
except IndexError :
    pass
print(stair_max_score[n])
```
  
**DFSë¡œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ê¸°ë³´ë‹¤ëŠ”, ê²°êµ­ ê° ê³„ë‹¨ë§ˆë‹¤ ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ìµœëŒ“ê°’ì´ ì¡´ì¬í•œë‹¤.** 
**ë”°ë¼ì„œ ë§ˆì§€ë§‰ ê³„ë‹¨ì— ë„ë‹¬í•˜ëŠ” ìµœëŒ“ê°’ì€,**  
**`ë§ˆì§€ë§‰ ê³„ë‹¨ - 2`ì˜ ì ìˆ˜ ë˜ëŠ” `ë§ˆì§€ë§‰ ê³„ë‹¨ - 3`ì˜ ì ìˆ˜ + `ë§ˆì§€ë§‰ ê³„ë‹¨ - 1`ì˜ ì ìˆ˜ ì¤‘ ë” í° ê°’ì— í˜„ì¬ ê³„ë‹¨ ì ìˆ˜ë¥¼ ë”í•œ ê²ƒì´ ëœë‹¤.**

<br>
<br>
<br>

---

# í•˜ì§€ë§Œ DPê°€ í•­ìƒ ì œì¼ ë¹ ë¥¸ ë°©ë²•ì€ ì•„ë‹ˆë‹¤.

## ë¬¸ì œ: [ë°±ì¤€ 17626](https://www.acmicpc.net/problem/17626) Four Squares
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>

ë¼ê·¸ë‘ì£¼ì˜ ë„¤ì œê³± ì •ë¦¬ì— ë”°ë¥´ë©´, ëª¨ë“  ìì—°ìˆ˜ëŠ” ë„· ë˜ëŠ” ê·¸ ì´í•˜ì˜ ì œê³±ìˆ˜ì˜í•©ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤  
ì˜ˆì‹œ - 15663 = 1252Â² + 62Â² + 12Â² + 12Â²  

ì •ìˆ˜ Nì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì •ìˆ˜ Nì„ ë‚˜íƒ€ë‚´ëŠ”ë° í•„ìš”í•œ ì œê³±ìˆ˜ì˜ ê°œìˆ˜ì˜ ìµœì†Ÿê°’ì„ êµ¬í•´ë¼
</details>

<br>

ì´ê²ƒë„ `DP`ë¥¼ ì‚¬ìš©í•´ì„œ, në³´ë‹¤ ì‘ì€ ì œê³±ìˆ˜ë“¤ì„ êµ¬í•œ í›„ì—,   
Nì—ì„œ ê° ì œê³±ìˆ˜ì„ ë¹¼ì„œ ë‚˜ì˜¨ ê°’ì˜ í•„ìš”í•œ ì œê³±ìˆ˜ì˜ ê°œìˆ˜ë¥¼ êµ¬í•œ í›„,   
ì˜ˆì‹œ : `1566 - 1252Â² = 4,132 = 62Â² + 12Â² + 12Â² -> 3ê°œ`  

ëª¨ë“  ì œê³±ìˆ˜ì— ì´ ê³¼ì •ì„ ë°˜ë³µí•´ì„œ ê°€ì¥ ì‘ì€ ê°’ +1 ì´ ë‹µì´ë‹¤.

ì´ ë°©ë²•ì´ í‹€ë¦° ê²ƒì€ ì•„ë‹ˆì§€ë§Œ, **ë” ë¹ ë¥´ê³  ì§ê´€ì ì¸ ë°©ë²•**ì´ ì¡´ì¬í•œë‹¤.
ê·¸ê²ƒì€ ìˆ˜í•™ì ì¸(ì •ìˆ˜ë¡ ) ë°©ë²•ì„ ì´ìš©í•˜ëŠ” ê²ƒì´ë‹¤

## ìˆ˜í•™ì ì¸ ë°©ë²•

```python
def how_many_primes(n):
    primes = [x*x for x in range(1,int(n**0.5)+1)]
    if n in primes:
        return 1
    for i in primes:
        if n - i in primes:
            return 2
    while n%4 == 0:
        n //= 4
    if n%8 == 7:
        return 4
    else :
        return 3

n = int(input())
print(how_many_primes(n))

```

#### 1. Në³´ë‹¤ ì‘ì€ ì œê³±ìˆ˜ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬í•œë‹¤  
â†’ ë§Œì•½ Nì´ ë¦¬ìŠ¤íŠ¸ì— ìˆë‹¤ë©´, ë‹µì€ `1`  
  
#### 2. Nì—ì„œ ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ì œê³±ìˆ˜ë¥¼ ëº€ë‹¤  
â†’ ë§Œì•½ì— ëº€ ê°’ì´ ë¦¬ìŠ¤íŠ¸ì— ìˆë‹¤ë©´ (ì œê³±ìˆ˜ë¼ë©´), ë‹µì€ `2`  

#### 3. Nì´ n, k âˆˆ â„¤âº âˆª {0}, N = 4â¿(8k + 7) ê¼´ì¸ì§€ í™•ì¸  
â†’ ë¼ê·¸ë‘ì£¼ì˜ ë„¤ ì œê³±ìˆ˜ ì •ë¦¬ì— ë”°ë¼, ë§Œì•½ Nì´ í•´ë‹¹ í˜•íƒœë¼ë©´, ë‹µì€ `4`

#### 4. ìœ„ 3ê°œ ì „ë¶€ í•´ë‹¹í•˜ì§€ ì•ŠìŒ
â†’  ë‹µì€ `3`
<br>

### ë‹¤ë§Œ, ìœ„ ë°©ë²•ì€ ì •ìˆ˜ë¡ ì„ ëª¨ë¥´ë©´ í’€ ìˆ˜ê°€ ì—†ë‹¤
ì •ìˆ˜ë¡ ì„ ëª¨ë¥¸ë‹¤ë©´ DPë¡œ í’€ë©´ ë˜ê² ì§€ë§Œ, ì¢‹ì€ ì½”ë“œë¥¼ ë§Œë“œëŠ” ì½”ë”ê°€ ë˜ê¸° ìœ„í•´ì„œëŠ”  
ìˆ˜í•™ì ì¸ ì§€ì‹ê³¼ ì‚¬ê³ ë„ ì¤‘ìš”í•˜ë‹¤ëŠ” ê²ƒì„ ê¹¨ë‹¬ì•˜ë‹¤.

---
## ğŸ—“ï¸ ì´ë²ˆ ì£¼ ê³„íš
- ğŸ“š ë°±ì¤€ í´ë˜ìŠ¤ 3 ë…íŒŒ
- ğŸ§  Class ê°œë… ì™„ë²½í•˜ê²Œ ìˆ™ì§€
- ğŸ“ ì´ì‚° ìˆ˜í•™ì—ì„œì˜ DAG, SCC ì••ì¶• ë“± ê·¸ë˜í”„ ì´ë¡  ê³µë¶€
- ğŸ Python ê¸°ì´ˆ ë¬¸ë²• ë³µìŠµ
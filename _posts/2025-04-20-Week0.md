---
title: "Week 0 : About DP and better options"
date: 2025-04-20
categories: [Weekly Report]
tags: [BOJ, Python, DFS/BFS, DP, Number Theory]
---

# ENGLISH
---
## About DP (Dynamic Programing)

Dynamic Programming (DP) is a method for solving problems by breaking them down into  
smaller overlapping subproblems, solving each subproblem only once,  
and reusing the result. 

---
# Working on it
---



<br>
<br>
<br>
<br>
<br>

# 한국어
---
## DP (동적 계획법)

동적 계획법은 문제를 해결할 때, 큰 문제를 작은 문제로 나눠서 푸는 방식이다.  
작은 문제들이 반복될 때, 한번 푼 작은 문제의 결과를 기억해서 다시 계산하지 않도록 하는 방법이다.  

이 방법은 생각보다 많이 유용하다. BFS/DFS 혹은 완전탐색을 할 때에 비해  
메모리 사용량이나 시간이 소요량 면에서 압도적으로 유리하기 때문이다.

아래의 코드는 BFS/DFS로 도전했다가 실패한 후, DP로 로직을 바꿔 테스트를 통과한 예시들이다.
<br>

---
## 문제: [백준 1463](https://www.acmicpc.net/problem/1463) 1로 만들기
<details>
<summary style="font-size: 20px;">문제 설명 보기</summary>
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.  
X가 3으로 나누어 떨어지면, 3으로 나눈다.  
X가 2로 나누어 떨어지면, 2로 나눈다.  
1을 뺀다.  

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다.   
연산을 사용하는 횟수의 최솟값을 출력하시오.
</details>

## BFS로 구현

```python
from collections import deque
n = int(input())
visited = set([x for x in range(2,n+1)]) # 그 숫자로 갔는지 확인
new = deque([(1,0)]) # BFS는 큐로 구현하는 것이 정석
while n in visited :
    index, num = new.popleft()
    next_number = index + 1
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number,num+1))
    next_number = index * 2
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number, num+1))
    next_number = index * 3
    if next_number <= n and next_number in visited :
        visited.remove(next_number)
        new.append((next_number, num+1))
print(num+1 if n != 1 else 0)
```

## DP로 구현

```python
n = int(input())
turns = [float("inf")] * (n+1)
turns[1] = 0
for i in range(2,n+1) :
    minimum = []
    if i%3 == 0 :
        minimum.append(turns[i//3])
    if i%2 == 0 :
        minimum.append(turns[i//2])
    minimum.append(turns[i-1])
    turns[i] = min(minimum) + 1
print(turns[n])
```

**BFS로 모든 경우의 수를 찾기보다는, 결국 어떤 숫자든 최소 횟수가 존재하고,**  
**자신이 찾고자 하는 숫자를 만들 수 있는 숫자에서 가지는 최솟값 +1 이 정답이다.**
<br>
<br>

---
## 문제: [백준 2579](https://www.acmicpc.net/problem/2579) 계단 오르기
<details>
<summary style="font-size: 20px;">문제 설명 보기</summary>

계단 n개는 각각 랜덤한 값을 가진다  
계단은 한번에 한 계단 혹은 두 계단씩 오를 수 있다  
연속된 3개의 계단을 밟을 수는 없다 (시작지점은 계단이 아님)  
마지막 계단은 반드시 밟아야한다

</details>

## DFS로 구현

```python
from collections import deque
n = int(input())
stairs = [0]
for _ in range(n) :
    stairs.append(int(input()))
que = deque([(0,0,0)])
total = set()
while que :
    score, succession, row = que.pop() # pop -> DFS, leftpop -> BFS?
    if row > n :
        continue
    if row == n :
        total.add(score)
        continue
    if row == n-1 :
        if succession < 2:
            row += 1
            que.append((score+stairs[row], succession+1,row))
            continue
        else :
            continue
    if succession < 2 :
        row += 1
        que.append((score+stairs[row], succession+1,row))
        row += 1
        que.append((score+stairs[row], 1,row))
    else :
        row += 2
        que.append((score+stairs[row], 1,row))

print(max(total))
```

## DP로 구현

```python
n = int(input())
stairs = [0]
for _ in range(n) :
    stairs.append(int(input()))
stair_max_score = [0] * (n+1)
try :
    stair_max_score[1] = stairs[1]
    stair_max_score[2] = stairs[2] + stairs[1]
    stair_max_score[3] = max(stairs[3] + stairs[1], stairs[3] + stairs[2])
    for i in range (4,n+1):
        stair_max_score[i] = max(stairs[i-1] + stair_max_score[i-3], stair_max_score[i-2]) + stairs[i]
except IndexError :
    pass
print(stair_max_score[n])
```
  
**DFS로 모든 경우의 수를 찾기보다는, 결국 어떤 계단이든 최댓값이 존재하고,**  
**`마지막계단-2`점수 와 `마지막계단-3` 점수 `+ 계단-1 점수` 중 큰 것 `+지금 계단 점수`가 정답이다**

<br>
<br>
<br>

---

# 하지만 DP가 항상 제일 빠른 방법은 아니다.

## 문제: [백준 17626](https://www.acmicpc.net/problem/17626) Four Squares
<details>
<summary style="font-size: 20px;">문제 설명 보기</summary>

라그랑주의 네제곱 정리에 따르면, 모든 자연수는 넷 또는 그 이하의 제곱수의합으로 표현할 수 있다  
예시 - 15663 = 1252² + 62² + 12² + 12²  

정수 N이 주어졌을 때, 정수 N을 나타내는데 필요한 제곱수의 개수의 최솟값을 구해라
</details>

<br>

이것도 `DP`를 사용해서, n보다 작은 제곱수들을 구한 후에,   
N에서 각 제곱수을 빼서 나온 값의 필요한 제곱수의 개수를 구한 후,   
`1566 - 1252² = 4,132 = 62² + 12² + 12² -> 3개`  

모든 제곱수에 이 과정을 반복해서 가장 작은 값 +1 이 답이다.

이 방법이 틀린 것은 아니지만, **더 빠르고 직관적인 방법**이 존재한다.
그것은 수학적인(정수론) 방법을 이용하는 것이다

## 수학적인 방법

```python
def how_many_primes(n):
    primes = [x*x for x in range(1,int(n**0.5)+1)]
    if n in primes:
        return 1
    for i in primes:
        if n - i in primes:
            return 2
    while n%4 == 0:
        n //= 4
    if n%8 == 7:
        return 4
    else :
        return 3

n = int(input())
print(how_many_primes(n))

```

#### 1. N보다 작은 제곱수의 리스트를 구한다  
→ 만약 N이 리스트에 있다면, 답은 `1`  
  
#### 2. N에서 리스트에 있는 제곱수를 뺀다  
→ 만약에 뺀 값이 리스트에 있다면 (제곱수라면), 답은 `2`  

#### 3. N이 n, k ∈ ℤ⁺ ∪ {0}, N = 4ⁿ(8k + 7) 꼴인지 확인  
→ 라그랑주의 네 제곱수 정리에 따라, 만약 N이 해당 형태라면, 답은 `4`

#### 4. 위 3개 전부 해당하지 않음
→  답은 `3`
<br>

### 다만, 위 방법은 정수론을 모르면 풀 수가 없다
정수론을 모른다면 DP로 풀면 되겠지만, 좋은 코드를 만드는 코더가 되기 위해서는  
수학적인 지식과 사고도 중요하다는 것을 깨달았다.

---
## 🗓️ 이번 주 계획
- 📚 백준 클래스 3 독파
- 🧠 Class 개념 완벽하게 숙지
- 📐 이산 수학에서의 DAG, SCC 압축 등 그래프 이론 공부
- 🐍 Python 기초 문법 복습
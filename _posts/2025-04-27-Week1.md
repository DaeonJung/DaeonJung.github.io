---
title: "Week 1 : Overall review of BOJ class 3"
date: 2025-04-27
categories: [Weekly Report]
tags: [BOJ, Python, Greedy, DFS/BFS, Two Pointers]
---

# ENGLISH
---
## ë°±ì¤€ Class 3 ì „ì²´ì ì¸ ë³µìŠµ

I recently completed Baekjoon Class 3.  
Unlike the previous classes, it contained many problems that required thinking across multiple fields, and there were several noteworthy aspects.  
Problems I have already covered separately, such as Baekjoon `2805`, `1541`, and `7569`, will not be discussed here.
<br>

---
## Problem: [BOJ 18111](https://www.acmicpc.net/problem/18111) Minecraft
<details>
<summary style="font-size: 20px;">Problem Description</summary>
The site is given as a 2D plane of size N Ã— M, and each cell can have a different ground height.
You must make all cells have the same height by either removing or adding blocks.  

Removing a block takes 2 seconds and adds the block to your inventory.  
Adding a block takes 1 second and consumes a block from your inventory.  

Initially, you have B blocks in your inventory, and you must always consider the inventory status when digging or placing blocks.  
You should try all possible target heights and find the option that requires the minimum time.  
If there are multiple options with the same minimum time, you must choose the one with the highest final ground height.


</details>

## Traversing list

```python
import sys
import heapq

h, w, inventory = map(int, sys.stdin.readline().strip().split())
ground = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(h)]

mini = min(min(row) for row in ground)
maxi = max(max(row) for row in ground)

heap = []
for level in range(mini, maxi + 1):
    time_spent = 0
    blocks = inventory
    for row in ground:
        for element in row:
            diff = element - level
            if diff > 0:  # mine a block
                time_spent += diff * 2
                blocks += diff
            elif diff < 0:  # stack a block
                time_spent += -diff
                blocks -= -diff
    if blocks >= 0:
        heapq.heappush(heap, (time_spent, -level))

a, b = heapq.heappop(heap)
print(a, -b)
```

## Using dictionary

```python
# use heapq
from collections import Counter
import sys
import heapq
h, w, inventory = map(int, sys.stdin.readline().strip().split())
ground = []
for _ in range(h):
    ground += list(map(int, sys.stdin.readline().strip().split()))
mini, maxi = min(ground), max(ground)
land = Counter(ground)          
heap = []
for level in range(mini, maxi+1):
    times = 0
    blocks = inventory
    for key, value in land.items():
        if key < level :
            times += value*(level-key)
            blocks -= value*(level-key)
        else : 
            times += 2*value*(key-level)
            blocks += value*(key-level)
    if blocks >= 0 : heapq.heappush(heap, (times, -level))
a, b = heapq.heappop(heap)
print(a,-b)
```

The first code stores the entire ground height information as a two-dimensional list and directly traverses every coordinate for each target height to calculate the required time.  
This approach is simple in structure and intuitive to implement, but it repeats an `O(N Ã— M)` operation every time, causing execution time to grow rapidly as the data size increases.  

In contrast, the second code flattens the ground heights into a one-dimensional list during input and uses a `Counter` to pre-count the number of blocks for each height.  
Thanks to this, when exploring target heights, it only needs to perform calculations proportional to the number of distinct heights, rather than traversing every cell.  
As a result, the performance gap between the two methods becomes more significant as the input size increases.  

Additionally, both codes use `heapq` to neatly handle the condition of "minimum time and maximum height," but the second approach is fundamentally more efficient in the way it computes the results.

<br>
<br>
<br>

---
## Problem: [BOJ 1931](https://www.acmicpc.net/problem/1931) Assigning a meeting room
<details>
<summary style="font-size: 20px;">Problem Description</summary>

Given a single meeting room, determine the maximum number of meetings that can be scheduled without overlapping.  
Each meeting has a given start and end time, and it is allowed for a **new meeting to start immediately after another meeting ends (== 0 Hour meeting).**  
Schedule as many meetings as possible.

</details>

## Greedy

```python
# 0 hour meeting What the fuck
import sys
n = int(sys.stdin.readline().strip())
timetable = {}
same = {}
for _ in range(n):
    start, ending = map(int, sys.stdin.readline().strip().split())
    if start == ending:
        same[start] = same.get(start, 0) + 1
    else : timetable[ending] = max(timetable.get(ending, 0), start)
timetable = dict(sorted(timetable.items()))
nowend = 0
count = 0
gap = set()
elsetime = set()
for ending, start in timetable.items():
    if start >= nowend:
        nowend = ending
        gap.update([start,ending])
        elsetime.update([x for x in range(start,ending)])
        count += 1
for k,v in same.items():
    if k in gap or k not in elsetime: 
        count += v
        continue
    if k in elsetime:
        count += v-1

print(count)
```
I seriously cursed while solving this problem â€” all because of that damn condition: **a meeting can start right after another one ends.**  

At first, I tried all sorts of methods before finally realizing that the key was **greedy**.  
If you pick the meeting that ends the earliest, you have the most remaining time left.  
The more time you have left, the more meetings you can fit in.  
So naturally, sorting meetings by their end time and picking them greedily leads to the maximum number of meetings scheduled.

But honestly, thatâ€™s not the real headache here.  
The real problem is **the existence of zero-duration meetings**.  
For example, suppose you pick the meetings from `1~3` and `3~5` following the greedy strategy.  
Now imagine there are `519` meetings scheduled at exactly `3~3` **(zero hour)**.  
You can shove all `519` of them between those two meetings, so you end up scheduling a total of 521 meetings...

That's already kind of ridiculous, but it gets worse.  
If there's a meeting from `1~4`, you would rather skip it entirely just to fit in all the zero-duration meetings instead.  
In short, you have to seriously rethink your plan just because of these weird cases.

Honestly, the fact that zero-duration meetings even need to be considered felt super wrong.
And the real kicker?
You can stack **as many zero-duration meetings as you want, without any limit!**
Isn't that just absurdly detached from common sense?
The problem setter clearly set this trap on purpose â€” and if you check the problem description from the link I shared, it only vaguely mentions that zero-duration meetings exist, but **it never explicitly says that you can stack hundreds or millions of them at the same time.**

### `Fuck you problem setter`

That being said, ignoring that mess, if you follow the standard **greedy** approach, itâ€™s a clean and nice problem.
So I decided to post it on my blog anyway.

<br>
<br>
<br>

---


## Problem: [BOJ 30804](https://www.acmicpc.net/problem/30804) Fruit Tanghulu
<details>
<summary style="font-size: 20px;">Problem Description</summary>

A tanghulu (candied skewer) has several fruits on it.  
You can remove some fruits from the front and back of the skewer to ensure that at most two types of fruits remain.  
The goal is to maximize the number of remaining fruits and find the maximum possible count.

</details>

## Two pointers

```python
from collections import deque
from collections import defaultdict
import sys
n = int(sys.stdin.readline().strip()) # 1 ~ 200,000
tanghulu = deque(list(map(int, sys.stdin.readline().strip().split()))) # 1~200,000
que = deque([])
new_fruit = tanghulu.popleft()
que.append(new_fruit)
dic = defaultdict(int)
dic[new_fruit] += 1
maxpile = 1
fruits = 1
while que:
    types = len(dic)
    if types <= 2:
        maxpile = max(maxpile, fruits)
    if types <= 2 and tanghulu:
        new_fruit = tanghulu.popleft()
        que.append(new_fruit)
        dic[new_fruit] += 1
        fruits += 1
    else :
        new_fruit = que.popleft()
        dic[new_fruit] -= 1
        if not dic[new_fruit]: del dic[new_fruit]
        fruits -= 1
print(maxpile)

```
In this code, the key point was to use the **two-pointer** technique to track the number of distinct `values` (fruits) between the pointers.  
Although using a `for` loop would be the standard approach, I tried implementing it once using a `queue` instead.  

At first, I used `types = len(set(que))` â€” basically converting the queue to a `set` every time I moved the pointer to count the number of distinct elements.
But doing that repeatedly caused massive bottlenecks.

So the method I ended up using was a simple `dictionary`.  
I realized that since fruits are being added and removed one at a time, I could just update the dictionary accordingly, without having to re-count the entire queue every single time.


<br>
<br>
<br>

---


## Problem: [BOJ 1629](https://www.acmicpc.net/problem/1629) Multiplication
<details>
<summary style="font-size: 20px;">Problem Description</summary>

You want to find the result of multiplying a natural number A by itself B times.  
Since the result can be extremely large, you need to calculate and output the remainder when it is divided by C.

</details>

## Divide and Conquer

```python
# print(pow(*tuple(map(int, input().split())))) # -> ì‚¬ì‹¤ ì´ê±° í•œì¤„ë¡œ ê°€ëŠ¥ ã…‹ã…‹
def multi(a,n,mod):
    if n == 0: return 1
    new = multi(a,n//2,mod)
    if n%2 == 0: return (new*new)%mod
    else: return (a*new*new)%mod

print(multi(*tuple(map(int, input().split()))))

```
Aside from the fact that the input numbers are insanely large, this was just an ordinary basic arithmetic problem.  
However, it was pretty interesting to learn that you could compute exponentiation much faster using divide and conquer techniques.  
Apparently, you can also use this method combined with matrices to calculate Fibonacci numbers extremely quickly... something to look into later.  

I also realized that applying the modulo operation to each part separately still produces the correct result.  
In formula terms, it would be something like `A*B mod m = (A mod m * B mod m) mod m`  
This problem really highlighted how lacking my understanding of modular arithmetic and congruences still is.  


<br>
<br>
<br>

---


## Problem: [BOJ 9019](https://www.acmicpc.net/problem/9019) DSLR
<details>
<summary style="font-size: 20px;">Problem Description</summary>

Given two numbers A and B between 0 and 9999, find the minimum number of operations needed to transform A into B using the following four operations:  

- D (Double): Multiply n by 2; if the result exceeds 9999, take the remainder after dividing by 10000.  
- S (Subtract): Subtract 1 from n; if n is 0, set it to 9999.  
- L (Left Shift): Rotate the digits of n one place to the left (d1 d2 d3 d4 â†’ d2 d3 d4 d1).  
- R (Right Shift): Rotate the digits of n one place to the right (d1 d2 d3 d4 â†’ d4 d1 d2 d3).  




</details>

## Bidirectional BFS

```python 
from collections import deque
import sys
def DSLR(start, aim):
    if start == aim : return []
    numbers = [([], 0) for _ in range(10000)] 
    # (command, visit status) (0 -> not visited / 1 -> reached by forward BFS / 
    # -1 -> reached by backward BFS)
    numbers[start] = ([],1)
    numbers[aim] = ([],-1)
    que = deque([start])
    reverse_que = deque([aim])
    def get_move(num):
        return [
            ("D", (2*num)%10000),
            ("S", (num-1)%10000),
            ("L", (num*10)%10000+num//1000),
            ("R", num//10+(num%10)*1000),
            ]
    def get_reverse_move(num):
        return [
            ("D", num//2),
            ("D", num//2+5000),
            # In the reverse direction, x2 can create two different cases. 
            # (This is why the levels built from each side can differ.)
            ("S", (num+1)%10000),
            ("L", num//10+(num%10)*1000),
            ("R", (num*10)%10000+num//1000),
            ]
    while True:
        n = len(que)
        # In bidirectional BFS, unlike unidirectional BFS, 
        # if the number of elements in the queue varies during each execution, 
        # alternating queues can cause depth (level) inconsistencies. 
        # Therefore, process all elements in the queue at once.
        for _ in range(n): 
            num = que.popleft()
            move = get_move(num)
            for new_prompt, next_num in move:
                if numbers[next_num][1] == -1:
                    return numbers[num][0] + [new_prompt] + numbers[next_num][0]
                if numbers[next_num][1] == 0:
                    que.append(next_num)
                    numbers[next_num] = (numbers[num][0] + [new_prompt], 1)
        n = len(reverse_que)
        for _ in range(n):
            num = reverse_que.popleft()
            move = get_reverse_move(num)
            for new_prompt, next_num in move:
                # Invalid condition / In other words, because of this, the levels (depths) can differ.
                if new_prompt == "D" and num%2 == 1: continue 
                if numbers[next_num][1] == 1:
                    return numbers[next_num][0] + [new_prompt] + numbers[num][0]
                if numbers[next_num][1] == 0:
                    reverse_que.append(next_num)
                    numbers[next_num] = ([new_prompt] + numbers[num][0], -1) # Marked as -1

for _ in range(int(sys.stdin.readline())):
    print("".join(DSLR(*tuple(map(int, sys.stdin.readline().split())))))

```
When using only unidirectional `BFS`, you end up exploring the path from the start number to the target number in one direction, and if the number of possibilities grows, memory and time usage quickly explode.

To overcome this, I introduced bidirectional `BFS`.
In DSLR, since the target number is known in advance and the possible number range `(0â€“9999)` is relatively small, it's easy to use memoization and merge the two searches when they meet in the middle.

However, there's a crucial detail during implementation: you must process all elements in the queue at once to avoid mixing up the search levels.
(In unidirectional `BFS`, it's fine, but in bidirectional `BFS`, managing the levels from both directions properly is absolutely critical.)

Also, in reverse `BFS`, the `D` operation (doubling) creates a special case because the division by `2` can lead to two different possibilities (depending on whether the number is even or odd).
Because of this, the levels where forward and backward searches meet may not align perfectly, and that needs to be handled carefully.

Initially, I didn't realize that the number of elements piled up in each direction wouldn't be the same, and I didn't process the whole queue at once â€”
Youâ€™ll know how it turns out too, the code blew up, along with my brain

<br>
<br>
<br>

---
## ğŸ—“ï¸ Plan for This Week
- ğŸ“š Solve problems from Baekjoon with various tags
- ğŸ§  Catch up on lost sleep from the exam period


<br>
<br>
<br>
<br>
<br>

# í•œêµ­ì–´
---
## ë°±ì¤€ Class 3 ì „ì²´ì ì¸ ë³µìŠµ

ì–¼ë§ˆì „ì— ë°±ì¤€ Class 3ë¥¼ ì™„ì£¼í–ˆë‹¤. ê·¸ ê³¼ì •ì—ì„œ ì´ì „ í´ë˜ìŠ¤ë“¤ê³¼ëŠ” ë‹¤ë¥´ê²Œ ì—¬ëŸ¬ ë¶„ì•¼ì—ì„œì˜ ì‚¬ê³ ë ¥ì„ ìš”êµ¬í•˜ëŠ” ë¬¸ì œë“¤ì´ ë§ì•˜ê³ , ì—¬ëŸ¬ ì£¼ëª©í•  ì ì´ ë§ì•˜ë‹¤.
ì´ì „ì— ë”°ë¡œ ë‹¤ë£¬ ë°±ì¤€ `2805`, `1541`, `7569`ëŠ” ë‹¤ë£¨ì§€ ì•ŠëŠ”ë‹¤.
<br>

---
## ë¬¸ì œ: [ë°±ì¤€ 18111](https://www.acmicpc.net/problem/18111) ë§ˆì¸í¬ë˜í”„íŠ¸
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>
ì§‘í„°ëŠ” N Ã— M í¬ê¸°ì˜ 2ì°¨ì› í‰ë©´ìœ¼ë¡œ ì£¼ì–´ì§€ë©°, ê° ì¹¸ë§ˆë‹¤ ë•…ì˜ ë†’ì´ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤.  
ë¸”ë¡ì„ ìºê±°ë‚˜, ì¶”ê°€í•˜ëŠ” ì‘ì—…ì„ í†µí•´ ëª¨ë“  ì¹¸ì˜ ë†’ì´ë¥¼ ë˜‘ê°™ì´ ë§ì¶°ì•¼ í•œë‹¤.

ë¸”ë¡ì„ ì œê±°í•  ë•ŒëŠ” 2ì´ˆê°€ ê±¸ë¦¬ê³ , ì¸ë²¤í† ë¦¬ì— ê·¸ ë¸”ë¡ì´ ì¶”ê°€ëœë‹¤.  
ë°˜ëŒ€ë¡œ, ë¸”ë¡ì„ ì¶”ê°€í•  ë•ŒëŠ” ì¸ë²¤í† ë¦¬ì—ì„œ ë¸”ë¡ì„ êº¼ë‚´ì•¼ í•˜ê³ , ì´ ì‘ì—…ì€ 1ì´ˆë§Œ ê±¸ë¦°ë‹¤.  

ì´ˆê¸°ì— ì¸ë²¤í† ë¦¬ì—ëŠ” Bê°œì˜ ë¸”ë¡ì´ ìˆìœ¼ë©°, ë•…ì„ ê¹ê±°ë‚˜ ìŒ“ì„ ë•ŒëŠ” ë°˜ë“œì‹œ ì¸ë²¤í† ë¦¬ ìƒíƒœë¥¼ ê³ ë ¤í•´ì•¼ í•œë‹¤.  
ê°€ëŠ¥í•œ ëª¨ë“  ëª©í‘œ ë†’ì´ë¥¼ ì‹œë„í•´ë³´ë©´ì„œ, ìµœì†Œ ì‹œê°„ì„ ë“¤ì´ëŠ” ê²½ìš°ë¥¼ ì°¾ëŠ”ë‹¤.  
ë§Œì•½ ê°™ì€ ìµœì†Œ ì‹œê°„ì´ ì—¬ëŸ¬ ë†’ì´ì—ì„œ ë‚˜ì˜¬ ê²½ìš°, ìµœì¢… ë•…ì˜ ë†’ì´ê°€ ë” ë†’ì€ ìª½ì„ ì„ íƒí•œë‹¤.
</details>

## ë¦¬ìŠ¤íŠ¸ ìˆœíšŒë¡œ í™•ì¸

```python
import sys
import heapq

h, w, inventory = map(int, sys.stdin.readline().strip().split())
ground = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(h)]

mini = min(min(row) for row in ground)
maxi = max(max(row) for row in ground)

heap = []
for level in range(mini, maxi + 1):
    time_spent = 0
    blocks = inventory
    for row in ground:
        for element in row:
            diff = element - level
            if diff > 0:  # ìºê¸°
                time_spent += diff * 2
                blocks += diff
            elif diff < 0:  # ìŒ“ê¸°
                time_spent += -diff
                blocks -= -diff
    if blocks >= 0:
        heapq.heappush(heap, (time_spent, -level))

a, b = heapq.heappop(heap)
print(a, -b)
```

## ë”•ì…”ë„ˆë¦¬ë¡œ êµ¬í˜„

```python
# ì¶œë ¥ í•œê°œë§Œ í• ë•ŒëŠ” heapqë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒë„ ì¢‹ë‹¤! 
from collections import Counter
import sys
import heapq
h, w, inventory = map(int, sys.stdin.readline().strip().split())
ground = []
for _ in range(h):
    ground += list(map(int, sys.stdin.readline().strip().split()))
mini, maxi = min(ground), max(ground)
# Counterë¡œ ë†’ì´ë§ˆë‹¤ ë¸”ë¡ ê°œìˆ˜ë¥¼ ì„¼ í›„ì— í•œë²ˆì— ì—°ì‚°í•˜ë©´ ì¼ì¼ì´ ë¦¬ìŠ¤íŠ¸ ìˆœíšŒë¥¼ í•  í•„ìš”ê°€ ì—†ìŒ! â˜†â˜†â˜†â˜†â˜†â˜†â˜†â˜†â˜†
land = Counter(ground)          
heap = []
for level in range(mini, maxi+1):
    times = 0
    blocks = inventory
    for key, value in land.items():
        if key < level :
            times += value*(level-key)
            blocks -= value*(level-key)
        else : 
            times += 2*value*(key-level)
            blocks += value*(key-level)
    if blocks >= 0 : heapq.heappush(heap, (times, -level))
a, b = heapq.heappop(heap)
print(a,-b)
```

ì²« ë²ˆì§¸ ì½”ë“œëŠ” ë•…ì˜ ì „ì²´ ë†’ì´ ì •ë³´ë¥¼ ì´ì¤‘ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ê·¸ëŒ€ë¡œ ì €ì¥í•œ ë’¤, ë§¤ ëª©í‘œ ë†’ì´ë§ˆë‹¤ ëª¨ë“  ì¢Œí‘œë¥¼ ì§ì ‘ ìˆœíšŒí•˜ë©° ì‘ì—… ì‹œê°„ì„ ê³„ì‚°í•œë‹¤.
ì´ ë°©ë²•ì€ êµ¬ì¡°ê°€ ë‹¨ìˆœí•˜ê³  êµ¬í˜„ì´ ì§ê´€ì ì´ì§€ë§Œ, ë§¤ë²ˆ `O(N Ã— M)`ì˜ ë°˜ë³µì„ í•˜ê²Œ ë˜ì–´ ë°ì´í„° í¬ê¸°ê°€ ì»¤ì§ˆìˆ˜ë¡ ì‹œê°„ì´ ê¸‰ê²©íˆ ëŠ˜ì–´ë‚œë‹¤.

ë°˜ë©´, ë‘ ë²ˆì§¸ ì½”ë“œëŠ” ì…ë ¥ì„ ë°›ì•„ì˜¬ ë•Œë¶€í„° ë•…ì˜ ë†’ì´ë¥¼ ì¼ë ¬ë¡œ ëª¨ì€ ë’¤ `Counter`ë¡œ ê° ë†’ì´ë³„ ë¸”ë¡ ê°œìˆ˜ë¥¼ ë¯¸ë¦¬ ì„¼ë‹¤.  
ì´ ë•ë¶„ì— ëª©í‘œ ë†’ì´ë¥¼ íƒìƒ‰í•  ë•Œ, ëª¨ë“  ì¹¸ì„ í•˜ë‚˜í•˜ë‚˜ ìˆœíšŒí•  í•„ìš” ì—†ì´ ë†’ì´ ì¢…ë¥˜ ìˆ˜ ë§Œí¼ë§Œ ì—°ì‚°í•œë‹¤.  
ê²°ê³¼ì ìœ¼ë¡œ ì…ë ¥ì´ ì»¤ì§ˆìˆ˜ë¡ ë‘ ë°©ë²• ì‚¬ì´ì˜ ì„±ëŠ¥ ì°¨ì´ëŠ” ì»¤ì§„ë‹¤.  

ë˜í•œ, ë‘ ì½”ë“œ ëª¨ë‘ `heapq`ë¥¼ ì‚¬ìš©í•´ì„œ "ìµœì†Œ ì‹œê°„, ìµœëŒ€ ë†’ì´" ì¡°ê±´ì„ ê¹”ë”í•˜ê²Œ ì²˜ë¦¬í–ˆëŠ”ë°, ë‘ ë²ˆì§¸ ë°©ì‹ì´ ê³„ì‚° ìì²´ë¥¼ ë” íš¨ìœ¨ì ìœ¼ë¡œ í–ˆë‹¤ëŠ” ì ì´ í•µì‹¬ì ì¸ ì°¨ì´ë‹¤.
<br>
<br>

---
## ë¬¸ì œ: [ë°±ì¤€ 1931](https://www.acmicpc.net/problem/1931) íšŒì˜ì‹¤ ë°°ì • 
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>

í•˜ë‚˜ì˜ íšŒì˜ì‹¤ì—ì„œ ì—¬ëŸ¬ íšŒì˜ë¥¼ ê²¹ì¹˜ì§€ ì•Šê²Œ ë°°ì •í•  ë•Œ, ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íšŒì˜ì˜ ìµœëŒ€ ê°œìˆ˜ë¥¼ êµ¬í•´ë¼.  
ê° íšŒì˜ëŠ” ì‹œì‘ê³¼ ë ì‹œê°„ì´ ì£¼ì–´ì§€ë©°, **ëë‚˜ìë§ˆì ë‹¤ë¥¸ íšŒì˜ê°€ ì‹œì‘ë˜ëŠ” ê²½ìš°ë„ ì¡´ì¬í•œë‹¤.**  
ê°€ëŠ¥í•œ ë§ì€ íšŒì˜ë¥¼ ë°°ì •í•´ë¼.  

</details>

## ê·¸ë¦¬ë””

```python
# 0 ì‹œê°„ì§œë¦¬ íšŒì˜ tlqkfë ¨ì•„
import sys
n = int(sys.stdin.readline().strip())
timetable = {}
same = {}
for _ in range(n):
    start, ending = map(int, sys.stdin.readline().strip().split())
    if start == ending:
        same[start] = same.get(start, 0) + 1
    else : timetable[ending] = max(timetable.get(ending, 0), start)
timetable = dict(sorted(timetable.items()))
nowend = 0
count = 0
gap = set()
elsetime = set()
for ending, start in timetable.items():
    if start >= nowend:
        nowend = ending
        gap.update([start,ending])
        elsetime.update([x for x in range(start,ending)])
        count += 1
for k,v in same.items():
    if k in gap or k not in elsetime: 
        count += v
        continue
    if k in elsetime:
        count += v-1

print(count)
```
ì´ ë¬¸ì œëŠ” í’€ë©´ì„œ ìš•ì´ ë‚˜ì™”ë‹¤. ë°”ë¡œ **ëë‚˜ìë§ˆì ë‹¤ë¥¸ íšŒì˜ê°€ ì‹œì‘ë˜ëŠ” ê²½ìš°ë„ ì¡´ì¬í•œë‹¤.** ë¼ëŠ” ì¡°ê±´ ë•Œë¬¸ì´ì—ˆë‹¤.  

ì²˜ìŒì—ëŠ” ë­ ì´ëŸ° ì €ëŸ° ë°©ë²•ì„ í•˜ë‹¤ê°€ ê²°êµ­ **ê·¸ë¦¬ë””**ë¼ëŠ” ê²ƒì„ ì•Œì•„ì±„ê¸°ëŠ” í–ˆë‹¤.  
ëë‚˜ëŠ” ì‹œê°„ì´ ê°€ì¥ ë¹ ë¥¸ íšŒì˜ë¥¼ ì°¾ê³ , ê·¸ íšŒì˜ë¥¼ ì œì¼ ë¨¼ì € ë°°ì •í•˜ë©´, ë‚¨ì€ ì‹œê°„ì´ ì œì¼ ë§ë‹¤.  
ê²°êµ­ ë‚¨ì€ ì‹œê°„ì´ ë§ì„ ìˆ˜ë¡ ë” ë§ì€ íšŒì˜ë¥¼ ë°°ì • í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, íšŒì˜ê°€ ëë‚˜ëŠ” ì‹œê°„ì´ ê°€ì¥ ë¹ ë¥¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ í•œ í›„ì—, íšŒì˜ ì‹œê°„ì´ ì œì¼ ì§§ì€ ìˆœìœ¼ë¡œ ë°°ì •í•˜ë©´ ìì—°ìŠ¤ë ˆ ì œì¼ ë§ì´ íšŒì˜ë¥¼ ë°°ì • í•  ìˆ˜  ìˆê²Œ ëœë‹¤. 

ë‹¤ë§Œ ì§„ì§œ ë¬¸ì œëŠ” ê·¸ê²Œ ì•„ë‹ˆë‹¤. ë°”ë¡œ **0ì‹œê°„ì§œë¦¬ íšŒì˜ê°€ ì¡´ì¬í•œë‹¤**ëŠ” ê²ƒì¸ë°, ì˜ˆë¥¼ ë“¤ì–´ì„œ ìœ„ì˜ ë°©ë²•ìœ¼ë¡œ 0ì‹œê°„ì§œë¦¬ íšŒì˜ë¥¼ ì œì™¸í•˜ê³  `1~3`ì‹œ, `3~5`ì‹œ íšŒì˜ë¥¼ ë°°ì •í•˜ëŠ” ê²ƒì´ ìµœì„ ì˜ ë°©ë²•ì´ë¼ê³  ìƒê°í•˜ì. ë§Œì•½ì—, ì´ë•Œ `3~3`ì‹œ **(0ì‹œê°„)** íšŒì˜ê°€ `519`ê°œ ì¡´ì¬í•œë‹¤ê³  í•˜ë©´, ê·¸ `519`ê°œì˜ íšŒì˜ê°€ ì•ì˜ ë‘ íšŒì˜ ì‚¬ì´ì— ì „ë¶€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆì–´ì„œ íšŒì˜ëŠ” ì´ `521`ê°œê°€ ëœë‹¤....

ë­ ì—¬ê¸°ê¹Œì§€ëŠ” ê·¸ëŸ´ ìˆ˜ ìˆì§€ë§Œ ë§Œì•½ íšŒì˜ê°€ `1~4`ì‹œê¹Œì§€ ì¡´ì¬í•œë‹¤ë©´? í•´ë‹¹ íšŒì˜ë¥¼ ë¹¼ê³  0ì‹œê°„ì§œë¦¬ íšŒì˜ë¥¼ ë°°ì •í•˜ëŠ”ê²Œ ë¬´ì¡°ê±´ ì´ë“ì´ë‹¤. ê·¸ë˜ì„œ ê³ ë ¤í•  ì‚¬í•­ì´ ë§ì€ ë¬¸ì œì˜€ë‹¤.

ì†”ì§íˆ ì´ ë¬¸ì œëŠ” 0ì‹œê°„ì§œë¦¬ íšŒì˜ë¥¼ ê³ ë ¤í•´ì•¼í•œë‹¤ëŠ” ì ë„ ì´ìƒí–ˆëŠ”ë°, ê·¸ 0ì‹œê°„ì§œë¦¬ íšŒì˜ê°€ **ëª‡ë²ˆì´ê³  ì¤‘ë³µí•´ì„œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆë‹¤**ëŠ” ì ì´ ë‚˜ë¥¼ í™”ë‚˜ê²Œ í–ˆë‹¤. ìƒì‹ê³¼ ë„ˆë¬´ ë™ë–¨ì–´ì ¸ ìˆì§€ ì•Šì€ê°€?
ë¬¸ì œ ì œì‘ìê°€ ì‘ì •í•˜ê³  í•¨ì •ì„ íŒ ê²ƒì¸ë°, ë§í¬ì— ë“¤ì–´ê°€ë³´ë©´ ì•Œê² ì§€ë§Œ 0ì‹œê°„ì§œë¦¬ íšŒì˜ê°€ ìˆì„ ìˆ˜ ìˆë‹¤ê³ ë§Œ ì–¸ê¸‰í•˜ì§€, **ì¤‘ë³µìœ¼ë¡œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆë‹¤ëŠ” ì´ì•¼ê¸°ëŠ” ì¼ì²´ ì–¸ê¸‰ë˜ì§€ ì•ŠëŠ”ë‹¤.**

ë‹¤ë§Œ, ê·¸ ì ì„ ì œì™¸í•˜ë©´ **ê·¸ë¦¬ë””**ë¡œ ê¹”ë”í•˜ê²Œ í’€ë¦´ ìˆ˜ ìˆëŠ” ë¬¸ì œì˜€ê¸° ë•Œë¬¸ì— ë¸”ë¡œê·¸ì— í•´ë‹¹ ë¬¸ì œë¥¼ ê²Œì‹œí•œë‹¤.

<br>
<br>
<br>

---


## ë¬¸ì œ: [ë°±ì¤€ 30804](https://www.acmicpc.net/problem/30804) ê³¼ì¼ íƒ•í›„ë£¨ 
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>

íƒ•í›„ë£¨ì—ëŠ” ì—¬ëŸ¬ê°œì˜ ê³¼ì¼ì´ ê½ƒí˜€ìˆë‹¤.  
íƒ•í›„ë£¨ì— ê½‚íŒ ê³¼ì¼ë“¤ ì¤‘ ì•ìª½ê³¼ ë’¤ìª½ì—ì„œ ì¼ë¶€ë¥¼ ì œê±°í•´, ë‚¨ì€ ê³¼ì¼ ì¢…ë¥˜ê°€ ìµœëŒ€ ë‘ ê°€ì§€ ì´í•˜ê°€ ë˜ë„ë¡ ë§Œë“ ë‹¤.  
ì´ë•Œ ë‚¨ê¸¸ ìˆ˜ ìˆëŠ” ê³¼ì¼ì˜ ê°œìˆ˜ê°€ ìµœëŒ€ê°€ ë˜ë„ë¡ í•˜ë©°, ê·¸ ìµœëŒ€ ê°œìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œë‹¤.

</details>

## íˆ¬ í¬ì¸í„°

```python
# ì¢…ë¥˜ë‚˜ ì¤‘ë³µì„ í™•ì¸ í•  ë•Œì—ëŠ” ë”•ì…”ë„ˆë¦¬ê°€ ì •ë§ ìœ ìš©í•˜ë‹¤!
from collections import deque
from collections import defaultdict
import sys
n = int(sys.stdin.readline().strip()) # 1 ~ 200,000
tanghulu = deque(list(map(int, sys.stdin.readline().strip().split()))) # 1~200,000
que = deque([])
new_fruit = tanghulu.popleft()
que.append(new_fruit)
dic = defaultdict(int)
dic[new_fruit] += 1
maxpile = 1
fruits = 1
while que: 
# ê²°êµ­ 1íšŒ ì‹œí–‰ í•  ë•Œë§ˆë‹¤ queì—ì„œ í•˜ë‚˜ë¥¼ ë¹¼ê±°ë‚˜ tanghuluì—ì„œ í•˜ë‚˜ë¥¼ ë¹¼ì•¼í•œë‹¤. 
# ì¦‰, ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜ëŠ” 400,000
    # types = len(set(que)) -> ë³‘ëª©ì˜ ì›ì¸ ë¹¼ë„ë¡ í•˜ì
    # ëŒ€ì‹ ì— defaultdictë¥¼ ì´ìš©í•´ì„œ ì¢…ë¥˜ ê°œìˆ˜ ê´€ë¦¬
    types = len(dic)
    if types <= 2:
        maxpile = max(maxpile, fruits)
    if types <= 2 and tanghulu:
        new_fruit = tanghulu.popleft()
        que.append(new_fruit)
        dic[new_fruit] += 1
        fruits += 1
    else :
        new_fruit = que.popleft()
        dic[new_fruit] -= 1
        if not dic[new_fruit]: del dic[new_fruit]
        fruits -= 1
print(maxpile)

#ì¸ë±ìŠ¤ 0, 0 ì—ë‹¤ê°€ í¬ì¸í„° start, end ë„£ê³ ,

# ë§Œì•½ start ~ endê¹Œì§€ ì¢…ë¥˜ê°€ 2ê°œë¼ë©´
# start - end + 1 ì €ì¥

# ë§Œì•½ end ëìë¦¬ë¼ë©´ ê·¸ëƒ¥ ê³„ì† start+1

# ë§Œì•½ 1ê°œ í˜¹ì€ 2ê°œë¼ë©´ 
# ê·¸ ë‹¤ìŒì€ end ë¥¼ í•œì¹¸ì”© ì˜®ê¸´ë‹¤. 
# 2ê°œê°€ ì•„ë‹ˆë¼ë©´ start + 1

# ëì€ ì–´ë–»ê²Œ ì„¤ì •í•˜ì§€?

# ê·¼ë° ìœ„ ê³¼ì •ì„ íë¡œ ì¬í˜„ ê°€ëŠ¥í•˜ì§€ ì•Šì„ê¹Œ? ì†”ì§íˆ ê·¸ê²Œ ë” í• ë§Œí•´ ë³´ì´ëŠ”ë°
# ë§¤ë²ˆ len() ì¬ê¸°ë„ ë” í¸í•˜ê³ 

```

í•´ë‹¹ ì½”ë“œëŠ” **íˆ¬ í¬ì¸í„°**ë¥¼ ì´ìš©í•´ì„œ í¬ì¸í„° ì‚¬ì´ì˜ `value`(ê³¼ì¼)ì˜ ì¢…ë¥˜ì˜ ê°œìˆ˜ë¥¼ ì¶”ì í•˜ëŠ” ê²ƒì´ í¬ì¸íŠ¸ì˜€ë‹¤.  
ë‹¤ë§Œ, ì›ë˜ëŠ” `for`ë¬¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì •ì„ì´ì§€ë§Œ, í•œë²ˆ `queue`ë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„í•´ ë³¸ ì½”ë“œì´ë‹¤.  

ì²˜ìŒì—ëŠ” `types = len(set(que))`ë¥¼ ì´ìš©í•´ í¬ì¸í„°ë¥¼ ì›€ì§ì¼ ë•Œë§ˆë‹¤, ê·¸ íë¥¼ `set`ë¡œ ë§Œë“¤ì–´ì„œ ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ ì…‹ëŠ”ë°, ì´ê±° ë§¤ë²ˆ í•˜ë‹ˆê¹Œ ë³‘ëª©í˜„ìƒì´ ì–´ë§ˆì–´ë§ˆí–ˆë‹¤.  
ê·¸ë˜ì„œ ì‚¬ìš©í•œ ë°©ë²•ì´ ë°”ë¡œ `dictionary` ì˜€ë‹¤.  
ìƒê°í•´ë³´ë‹ˆ ì–´ì°¨í”¼ ë“¤ì–´ì˜¤ëŠ” ê³¼ì¼ì„ ë”•ì…”ë„ˆë¦¬ì— ì €ì¥ë§Œ í•˜ë©´ ë§¤ë²ˆ íì— ìˆëŠ” ìš”ì†Œì˜ ì¢…ë¥˜ê°€ ëª‡ê°œì¸ì§€ ì…€ í•„ìš”ê°€ ì—†ë‹¤ê³  íŒë‹¨í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

<br>
<br>
<br>

---


## ë¬¸ì œ: [ë°±ì¤€ 1629](https://www.acmicpc.net/problem/1629) ê³±ì…ˆ
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>

ìì—°ìˆ˜ Aë¥¼ Bë²ˆ ê³±í•œ ìˆ˜ë¥¼ ì•Œê³  ì‹¶ë‹¤. ë‹¨ êµ¬í•˜ë ¤ëŠ” ìˆ˜ê°€ ë§¤ìš° ì»¤ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì´ë¥¼ Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

</details>

## ë¶„í•  ì •ë³µ

```python
# print(pow(*tuple(map(int, input().split())))) # -> ì‚¬ì‹¤ ì´ê±° í•œì¤„ë¡œ ê°€ëŠ¥ ã…‹ã…‹
def multi(a,n,mod):
    if n == 0: return 1
    new = multi(a,n//2,mod)
    if n%2 == 0: return (new*new)%mod
    else: return (a*new*new)%mod

print(multi(*tuple(map(int, input().split()))))

```
ì…ë ¥ ìˆ«ìê°€ ì—„ì²­ë‚˜ê²Œ í¬ë‹¤ëŠ” ì ë§Œ ì œì™¸í•˜ë©´ í‰ë²”í•œ ì‚¬ì¹™ì—°ì‚° ë¬¸ì œì´ë‹¤.
ë‹¤ë§Œ ë¶„í• ì •ë³µì„ í†µí•´ì„œ ë¹ ë¥´ê²Œ ê±°ë“­ì œê³±ì„ êµ¬í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì€ í¥ë¯¸ë¡œì› ë‹¤.  
ë‚˜ì¤‘ì—ëŠ” í–‰ë ¬ê³¼ ì—°ê³„í•˜ì—¬ í”¼ë³´ë‚˜ì¹˜ìˆ˜ë„ êµ‰ì¥íˆ ë¹¨ë¦¬ êµ¬í•  ìˆ˜ ìˆë‹¤ë˜ë°...  

ê·¸ë¦¬ê³  ëª¨ë‘˜ëŸ¬ ì—°ì‚°ì„ ê° ë¶€ë¶„ì— ëŒ€í•´ì„œ ì‹œí–‰í•˜ì—¬ë„ ê²°ê³¼ì— ì‹œí–‰í•œê²ƒê³¼ ê°™ë‹¤ëŠ” ê²ƒì„ ì•Œì•„ëƒˆë‹¤.  
ìˆ˜ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚¸ë‹¤ë©´ `A*B mod m = (A mod m * B mod m) mod m` ì´ë ¤ë‚˜
í•©ë™ì‹ì— ëŒ€í•œ ë‚˜ì˜ ì´í•´ë„ ë¶€ì¡±ì´ ì—¬ì‹¤íˆ ë“¤ì–´ë‚˜ëŠ” ë¬¸ì œì˜€ë‹¤.


<br>
<br>
<br>

---


## ë¬¸ì œ: [ë°±ì¤€ 9019](https://www.acmicpc.net/problem/9019) DSLR
<details>
<summary style="font-size: 20px;">ë¬¸ì œ ì„¤ëª… ë³´ê¸°</summary>

0ë¶€í„° 9999ì‚¬ì´ì˜ ë‘ ìˆ«ì A, Bê°€ ì£¼ì–´ì§ˆ ë•Œ, Aì— ì•„ë˜ ë„¤ê°œì˜ ì—°ì‚°ì„ í•˜ì—¬ Bë¡œ ë§Œë“œëŠ” ê²½ìš°ì˜ ìµœì†Œ ì—°ì‚° íšŸìˆ˜ë¥¼ êµ¬í•˜ë¼.  

- D (Double): nì„ 2ë°°ë¡œ ë§Œë“¤ê³ , 10000ì„ ë„˜ìœ¼ë©´ 10000ìœ¼ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ ì €ì¥í•œë‹¤.  
- S (Subtract): nì—ì„œ 1ì„ ë¹¼ê³ , nì´ 0ì´ë©´ 9999ë¥¼ ì €ì¥í•œë‹¤.  
- L (Left Shift): nì˜ ìë¦¿ìˆ˜ë¥¼ ì™¼ìª½ìœ¼ë¡œ í•œ ì¹¸ì”© íšŒì „ì‹œì¼œ ì €ì¥í•œë‹¤ (d1 d2 d3 d4 â†’ d2 d3 d4 d1).  
- R (Right Shift): nì˜ ìë¦¿ìˆ˜ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œ ì¹¸ì”© íšŒì „ì‹œì¼œ ì €ì¥í•œë‹¤ (d1 d2 d3 d4 â†’ d4 d1 d2 d3).  


</details>

## ì–‘ë°©í–¥ BFS

```python 
from collections import deque
import sys
def DSLR(start, aim):
    if start == aim : return []
    numbers = [([], 0) for _ in range(10000)] 
    #(ëª…ë ¹ì–´,ë°©ë¬¸ìƒíƒœì²´í¬)(0 -> ì•ˆê° / 1 -> ì •ë°©í–¥ BFS ë„ì°© / 2 -> ì—­ë°©í–¥ BFS ë„ì°©)
    numbers[start] = ([],1)
    numbers[aim] = ([],-1)
    que = deque([start])
    reverse_que = deque([aim])
    def get_move(num):
        return [
            ("D", (2*num)%10000),
            ("S", (num-1)%10000),
            ("L", (num*10)%10000+num//1000),
            ("R", num//10+(num%10)*1000),
            ]
    def get_reverse_move(num):
        return [
            ("D", num//2),
            ("D", num//2+5000), 
            # ì—­ë°©í–¥ì—ì„œëŠ” x2ê°€ ë‘ê°€ì§€ ê²½ìš°ê°€ ìƒê¸´ë‹¤. (ì´ê²ƒë•Œë¬¸ì— ì„œë¡œ ìŒ“ì´ëŠ” ë ˆë²¨(ê¹Šì´)ì´ ë‹¤ë¥´ê¸°ë„í•¨)
            ("S", (num+1)%10000),
            ("L", num//10+(num%10)*1000),
            ("R", (num*10)%10000+num//1000),
            ]
    while True:
        n = len(que)
        # ë‹¨ë°©í–¥ BFSì™€ ë‹¤ë¥´ê²Œ, í•œë²ˆ ì‹¤í–‰ì‹œë§ˆë‹¤ íì— ìŒ“ëŠ” ê°œìˆ˜ê°€ ë‹¤ë¥´ë©´, 
        # ë²ˆê°ˆì•„ì„œ í˜¸ì¶œ í•  ê²½ìš° ë ˆë²¨(ê¹Šì´)ê°€ ë“¤ì­‰ë‚ ì­‰í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ íë¥¼ í•œë²ˆì— ë‹¤ í„¸ê³  ê°ˆ ê²ƒ
        for _ in range(n): 
            num = que.popleft()
            move = get_move(num)
            for new_prompt, next_num in move:
                if numbers[next_num][1] == -1:
                    return numbers[num][0] + [new_prompt] + numbers[next_num][0]
                if numbers[next_num][1] == 0:
                    que.append(next_num)
                    numbers[next_num] = (numbers[num][0] + [new_prompt], 1)
        n = len(reverse_que)
        for _ in range(n):
            num = reverse_que.popleft()
            move = get_reverse_move(num)
            for new_prompt, next_num in move:
                # ì•ˆë¼ëŠ” ì¡°ê±´ / ë‹¤ì‹œ ë§í•´ì„œ ì´ê²ƒë•Œë¬¸ì— ì„œë¡œ ìŒ“ì´ëŠ” ë ˆë²¨(ê¹Šì´)ì´ ë‹¤ë¥´ë‹¤
                if new_prompt == "D" and num%2 == 1: continue 
                if numbers[next_num][1] == 1:
                    return numbers[next_num][0] + [new_prompt] + numbers[num][0]
                if numbers[next_num][1] == 0:
                    reverse_que.append(next_num)
                    numbers[next_num] = ([new_prompt] + numbers[num][0], -1) # -1 ë„£ì—ˆìŒ

for _ in range(int(sys.stdin.readline())):
    print("".join(DSLR(*tuple(map(int, sys.stdin.readline().split())))))

```
ë‹¨ë°©í–¥ `BFS`ë§Œ ì‚¬ìš©í•  ê²½ìš°, ì‹œì‘ ìˆ«ìì—ì„œ ëª©í‘œ ìˆ«ìê¹Œì§€ì˜ ê²½ë¡œë¥¼ ì¼ë°©ì ìœ¼ë¡œ íƒìƒ‰í•˜ê¸° ë•Œë¬¸ì—, ê²½ìš°ì˜ ìˆ˜ê°€ ë§ì•„ì§€ë©´ ë©”ëª¨ë¦¬ì™€ ì‹œê°„ì´ í­ë°œí•˜ê²Œ ëœë‹¤.  

ì´ë¥¼ ê·¹ë³µí•˜ê¸° ìœ„í•´ ì–‘ë°©í–¥ `BFS`ë¥¼ ë„ì…í•˜ì˜€ë‹¤.
DLSRì—ì„œëŠ” ëª©í‘œ ìˆ«ìë¥¼ ì •í™•íˆ ì•Œ ìˆ˜ ìˆê³ , ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ìˆ«ìì˜ ë²”ìœ„ë„ `0~9999`ë¡œ ë§ì§€ ì•Šê¸° ë•Œë¬¸ì— ë©”ëª¨ì´ì œì´ì…˜ì„ í†µí•´ì„œ ì¤‘ê°„ì—ì„œ ë§Œë‚  ë•Œ í•©ì¹˜ê¸°ë„ ì‰½ë‹¤.  

ë‹¤ë§Œ, êµ¬í˜„ ì‹œ ì£¼ì˜í•  ì ì€ í•œ ë²ˆì— íì— ìˆëŠ” ì›ì†Œë“¤ì„ ëª¨ë‘ í„¸ì–´ì•¼ ê¹Šì´(level)ê°€ ë’¤ì„ì´ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì´ë‹¤.
(ë‹¨ë°©í–¥ `BFS`ì—ì„œëŠ” ê´œì°®ì§€ë§Œ, ì–‘ë°©í–¥ì—ì„œëŠ” ê° ë°©í–¥ì˜ ë ˆë²¨ ê´€ë¦¬ê°€ ë§¤ìš° ì¤‘ìš”í•´ì§„ë‹¤.)

ê·¸ë¦¬ê³  ì—­ë°©í–¥ `BFS`ì—ì„œëŠ” `D` ì—°ì‚°(ê³±í•˜ê¸° 2)ì˜ ê²½ìš° ë‚˜ëˆ—ì…ˆ ê²°ê³¼ê°€ ì—¬ëŸ¬ ê°ˆë˜(ì§ìˆ˜ì™€ í™€ìˆ˜)ë¡œ ë‚˜ë‰˜ëŠ” íŠ¹ìˆ˜í•œ ê²½ìš°ë¥¼ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ì–´ì•¼ í–ˆë‹¤.
ì´ë¡œ ì¸í•´ ì •ë°©í–¥ íƒìƒ‰ê³¼ ì—­ë°©í–¥ íƒìƒ‰ì´ ë§Œë‚˜ëŠ” ë ˆë²¨ì´ ì™„ì „íˆ ëŒ€ì¹­ì´ ë˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆë‹¤ëŠ” ì ë„ ê³ ë ¤í–ˆë‹¤.

ì²˜ìŒì— ìŒ“ì¸ ì›ì†Œì˜ ê°œìˆ˜ê°€ ì–‘ìª½ì— ëª¨ë‘ ë™ì¼í•˜ì§€ ì•Šë‹¤ëŠ” ì , ê·¸ì— ë”°ë¼ ì›ì†Œë¥¼ ëª¨ë‘ í„¸ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ëª¨ë¥¸ ì±„ë¡œ ì½”ë“œë¥¼ ì§¯ë‹¤ê°€ ì˜¤ë‹µì´ í­ë°œí•´ë²„ë ¤ì„œ ë‚´ ë¨¸ë¦¬ë„ ê°™ì´ í­ë°œí•´ë²„ë ¸ë‹¤.  

<br>
<br>
<br>

---
## ğŸ—“ï¸ ì´ë²ˆ ì£¼ ê³„íš
- ğŸ“š ë°±ì¤€ ë‹¤ì–‘í•œ íƒœê·¸ì˜ ë¬¸ì œ í’€ê¸°
- ğŸ§  ì‹œí—˜ê¸°ê°„ì´ë¼ ì  ëª»ì”ê±° íšŒë³µí•˜ê¸°